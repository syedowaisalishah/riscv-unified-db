# yaml-language-server: $schema=../../../schemas/inst_schema.json

$schema: "inst_schema.json#"
kind: instruction
name: amocas.d
long_name: No synopsis available.
description: |
  No description available.
definedBy: Zacas
assembly: xd, xs1, xs2, aq, rl
encoding:
  match: 00101------------011-----0101111
  variables:
    - name: aq
      location: 26-26
    - name: rl
      location: 25-25
    - name: rs2
      location: 24-20
    - name: rs1
      location: 19-15
    - name: rd
      location: 11-7
access:
  s: always
  u: always
  vs: always
  vu: always
data_independent_timing: false
operation(): |
  # Ensure the Zacas extension is implemented and enabled
  if (!implemented?(ExtensionName::Zacas)) {
    raise (ExceptionCode::IllegalInstruction, mode(), $encoding);
  }

  # Calculate the effective address from rs1 directly without using 'let'
  effective_address = X[rs1];

  # Load the 64-bit value from the effective address directly
  loaded_value = mem_read64(effective_address, aq);

  # Initialize and assign values directly within the condition blocks
  compare_value_low = 0;
  compare_value_high = 0;
  swap_value_low = 0;
  swap_value_high = 0;

  if (rd != 0) {
    compare_value_low = X[rd];
    compare_value_high = X[rd + 1];
  }

  if (rs2 != 0) {
    swap_value_low = X[rs2];
    swap_value_high = X[rs2 + 1];
  }

  # Combine high and low parts for full 64-bit values directly in the expression
  compare_value = (compare_value_high << 32) | compare_value_low;
  swap_value = (swap_value_high << 32) | swap_value_low;

  # Perform the comparison and conditional swap
  if (loaded_value == compare_value) {
    mem_write64(effective_address, swap_value, rl);
  }

  # Update the register pair with the loaded value if rd is not x0
  if (rd != 0) {
    X[rd] = loaded_value & 0xFFFFFFFF;  # Low part of the 64-bit value
    X[rd + 1] = (loaded_value >> 32) & 0xFFFFFFFF;  # High part of the 64-bit value
